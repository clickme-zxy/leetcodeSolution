import java.util.HashMap;
/*
* 判断回文
* 1.想要获得第一个字母和最后一个字母，并且进行对比
* 方法1：
* 转化为string
* 问题：会开辟额外的空间
* 方法2：将整个数字进行反转
* 制造两个数，一个是将所有的数进行反转，一个是x本身。
* 然后如果两个数相等，那么意味着数字是相同的。
* 边界：X小于0，是个负数，那么一定不会相等。
* 存在问题：如果x=Integer.MAX_VALUE那么就会导致反转的时候越界
*
* =》优化
* 方法2：反转一半的数字
* 将后半段的数字进行反转，那么前后半段的数，将会分离，再分别从末尾开始比较。
* 什么时候反转结束呢？当num2(反装数字）>=num1（前半段数字的时候）就可以结束了
* 非常漂亮的返回：我们必须考虑到奇数和偶数是不同的情况，
* 也就意味着，奇数的时候 num2多了一个数
* 偶数的时候，num2和num1相等。
* 这是一道非常漂亮的题目，直接返回了num1==num2||num1==num2/10
*
* 需要考虑边界和特殊情况：
* 比如：负数||比如特殊的末尾为0，但是数不为0
* */
public class Number9 {
    public boolean isPalindrome(int x) {
        if(x<0||(x%10==0&&x!=0)) return false;
        int num1=x;
        int num2=0;
        while(num2<num1){
            num2=num1%10+num2*10;
            num1=num1/10;
        }
        return num1==num2||num1==num2/10;
    }
}
